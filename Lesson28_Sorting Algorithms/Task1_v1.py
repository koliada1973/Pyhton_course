# Task 1:
# Сортування бульбашкою можна модифікувати для "бульбашкового" сортування в обох напрямках.
# Перший прохід переміщує список "вгору", а другий - "вниз".
# Таке чергування триває доти, доки не знадобиться більше проходів.
# Застосуйте цю варіацію і опишіть, за яких обставин вона може бути доречною.

def bubbleSort_plus(iterable):
    # Флаг того, що під час проходу було переставлено деякі елементи,
    # і потрібно зробити наступний цикл сортування:
    OK = True
    # Задаємо діапазон сортування (початок, кінець і крок) для використання в функції range
    start = 0
    stop = len(iterable)-1
    step = 1
    while OK:
        OK = False
        for i in range(start, stop, step):
            # Якщо перший елемент більше другого - міняємо їх містами
            # і встановлюємо флаг того, що відбувся обмін позиціями елементів на True:
            if iterable[i] > iterable[i + 1]:
                iterable[i], iterable[i + 1] = iterable[i + 1], iterable[i]
                OK = True
        # Після кожного циклу сортування потрібно корегувати диапазон сортування і направлення циклу сортування:
        # Після кожного проходу міняємо містами початок і кінець діапазону для наступного проходу
        start, stop = stop, start
        # Якщо був прямий прохід (крок позитивний):
        if step > 0:
            # Зменшуємо диапазон сортування з хвоста (який тепер буде початком для наступного зворотнього проходу) на один елемент
            start -= 1
            # А також зменшуємо індекс початку диапазону (який тепер буде хвостом для наступного зворотнього проходу),
            # бо при зворотньому проході цикл доходить до stop, але не включаючи його
            stop -= 1
            # Після самого першого прямого проходу потрібно індекс голови списка змінити на -1
            # (щоб наступний зворотній прохід включив в обробку нульовий елемент списку):
            if start == len(iterable) - 2 and stop == 0:
                stop = -1
        # Якщо був зворотній прохід (крок негативний):
        elif step < 0:
            # Знову ж таки після першого зворотнього проходу потрібно індекс голови списка повернути на 0
            if start == -1:
                start = 0
            # Зменшуємо диапазон сортування з голови
            start += 1
        # А також змінюємо шаг на протилежний
        step *=-1
    return iterable

# Використання
if __name__ == '__main__':
    import random

    # l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    # random.shuffle(l)
    l = [4, 4, 3, 6, 2, 4, 4, 4, 8, 1]
    print(f'Невідсортований список: {l}')

    b = bubbleSort_plus(l)
    print(f'Відсортований список:   {b}')

# За яких обставин цей варіант може бути доречним? Важко сказати...можливо у випадку невеликих списків...
# Виглядає як більш оптимізоване сортування бульбашкою, але складність O(n²) все одно зберігається.